## Context

当前记账助手应用基于 Tauri 2.0 + Vue 3 架构,使用 Sea-ORM 2.0 进行 SQLite 数据库操作。应用已有完整的实体定义和服务层架构,包括 accounting_record 和 accounting_record_seq 两个实体。后端采用多层架构:命令层 → 服务层 → 数据访问层 → 数据库层。

现有项目特点:
- Entity-first 数据库设计方式,Sea-ORM 实体定义后自动同步 schema
- 全局连接池管理在 `db::connection` 模块
- 使用 Tokio 异步运行时和 Rust AsyncStream
- Tauri 的 app_data_dir 作为应用数据存储位置

## Goals / Non-Goals

**Goals:**
- 创建完整的附件实体定义,符合 Sea-ORM 规范
- 实现健壮的文件存储系统,按月归档文件以避免单目录文件过多
- 提供类型安全的附件 CRUD 服务接口
- 实现清晰可用的 Tauri IPC 命令供前端调用
- 支持分页和多种筛选条件的查询功能

**Non-Goals:**
- 前端 UI 实现和对接(仅完成后端功能)
- 文件类型验证(仅存储文件基本信息)
- 文件内容预览或缩略图生成
- 云存储集成(仅本地存储)
- 附件与记账记录的关联逻辑(仅提供 master_id 字段)

## Decisions

### 1. 实体设计:使用 i64 主键而非字符串 ID

**决策:** Attachment 实体使用 `i64` 类型的自增主键,与 accounting_record 的字符串 ID 不同。

**原因:**
- accounting_record 使用业务相关的日期序号格式(YYYYMMDDNNNNN),便于人工识别
- 附件是辅助数据,使用自增主键更简单高效
- 附件主要通过文件路径访问,无需人工记忆 ID
- 符合 Sea-ORM 的推荐实践,利用数据库自增特性

### 2. 文件存储路径:按月归档 + 时间戳前缀

**决策:** 存储路径格式为 `fileStorage/attachment/[YYYY-MM]/[timestamp]-filename`

**原因:**
- 按月归档可避免单目录文件过多(Windows FAT32 限制 65535 个文件)
- 时间戳前缀确保文件名唯一,避免同月同名文件覆盖
- 月度目录便于定期归档和清理
- 路径结构清晰,便于人工查找和管理

**替代方案考虑:**
- 按年归档:单目录可能积累过多文件
- 按天归档:目录层级过深,管理复杂
- UUID 命名:不可读,难以人工识别
- MD5 命名:计算开销大,不可读

### 3. 文件大小字段:使用 String 类型

**决策:** file_size 字段使用 `String` 类型存储文件大小(如 "1024 KB", "2.5 MB")。

**原因:**
- 人性化的单位显示,便于前端直接展示
- 避免数字过大(字节值可达 GB 级别)
- 前端无需额外转换逻辑

**替代方案考虑:**
- u64 字节值:数字过大,需转换,不直观
- f64 大小值:浮点精度问题,需要约定单位

### 4. 服务层设计:独立的 AttachmentService 模块

**决策:** 创建独立的 `src-tauri/src/services/attachment.rs` 模块,不与现有服务耦合。

**原因:**
- 单一职责原则,附件管理功能独立完整
- 便于未来复用(如其他模块也可能需要附件)
- 清晰的模块边界,易于测试和维护

**替代方案考虑:**
- 集成到 AccountingRecordService:耦合度高,违反单一职责
- 合并到通用 Service 模块:缺乏清晰的职责划分

### 5. 异步文件操作:使用 tokio::fs

**决策:** 使用 `tokio::fs` 进行异步文件操作,保持与 Tauri 异步运行时一致。

**原因:**
- 项目已使用 Tokio 异步运行时,保持一致
- 避免阻塞 Tauri 事件线程,保证 UI 响应性
- 大文件读写不会卡死应用

**替代方案考虑:**
- std::fs 同步操作:会阻塞主线程,导致 UI 卡顿
- 使用 sidecar 进程:过度设计,增加复杂度

## Risks / Trade-offs

### 1. 文件删除 orphan 风险

**风险:** 删除附件实体时可能只删除数据库记录,未删除物理文件;或删除物理文件但数据库记录仍存在。

**缓解措施:**
- 删除附件时同时删除数据库记录和物理文件,使用事务保证原子性
- 定期维护脚本清理 orphan 文件
- 前端通过 master_id 关联删除主记录时,级联删除相关附件

### 2. 文件并发写入冲突

**风险:** 多个附件同时写入可能导致文件名冲突或目录创建失败。

**缓解措施:**
- 使用高精度时间戳(毫秒级)减少冲突概率
- 文件目录创建使用 `create_dir_all` 避免目录不存在错误
- 错误处理捕获并报告具体错误信息

### 3. 存储空间无限制

**风险:** 用户可能上传大量大文件占用磁盘空间。

**缓解措施:**
- 当前阶段不限制,属于已知限制
- 未来可考虑文件大小限制、总容量限制
- 查询接口提供按大小排序,便于识别大文件

### 4. 跨平台路径兼容性

**风险:** Windows 和 Unix 文件路径分隔符不同。

**缓解措施:**
- 使用 `PathBuf` 和 `Path` 类型处理路径
- 避免手动拼接路径字符串
- 使用 `std::path::MAIN_SEPARATOR` 或 Path API

### 5. 分页查询性能

**风险:** 附件数量多时,复杂筛选条件可能影响查询性能。

**缓解措施:**
- 确保 create_at 字段建立索引
- 使用 Sea-ORM 的分页特性(limit/offset)
- SQLite 对时间范围查询有索引支持

## Migration Plan

### 部署步骤

1. 代码变更
   - 创建 `src-tauri/src/entity/attachment.rs` 实体定义
   - 创建 `src-tauri/src/services/attachment.rs` 服务模块
   - 创建 `src-tauri/src/commands/attachment.rs` Tauri 命令
   - 在 `src-tauri/src/lib.rs` 注册新命令

2. 数据库迁移
   - Sea-ORM 在应用启动时自动同步 schema
   - attachment 表将自动创建
   - 无需手动 SQL 迁移脚本

3. 验证
   - 运行 `pnpm tauri dev` 测试附件功能
   - 测试附件创建、查询、删除、下载各功能
   - 验证文件存储路径正确性

### 回滚策略

- 数据库:删除 attachment 表(或重新部署旧版本代码,Sea-ORM 会保留表但不再使用)
- 代码:Git revert 到变更前 commit
- 文件:fileStorage/attachment/ 目录需手动清理(或保留以供后续恢复)

## Open Questions

1. **附件与记账记录关联时机**: 当前设计仅在附件实体中保留 master_id 字段,记账记录删除时是否需要级联删除附件?
   - 建议:需要级联删除,前端调用记账记录删除命令时,服务层先删除相关附件

2. **文件类型限制**: 是否限制可上传的文件类型?
   - 当前阶段不限制,用户可上传任意文件
   - 未来可考虑白名单或黑名单机制

3. **附件数量限制**: 单个主记录可关联多少附件?
   - 当前不限制
   - 未来可考虑性能测试后设置上限

4. **附件搜索扩展性**: 是否需要支持附件内容全文搜索(如 OCR 识别)?
   - 当前不支持,仅支持元数据搜索
   - 未来可通过 sidecar 进程集成 OCR 服务
